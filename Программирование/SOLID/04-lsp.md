# Глава 3: Liskov Substitution Principle (LSP) - Принцип подстановки Лисков

## Оглавление

- [Теоретические основы](#теоретические-основы)
- [Почему LSP важен?](#почему-lsp-важен)
- [Условия соблюдения LSP](#условия-соблюдения-lsp)
- [Распознавание нарушений LSP](#распознавание-нарушений-lsp)
- [Пример нарушения LSP: Классический пример с Rectangle и Square](#пример-нарушения-lsp-классический-пример-с-rectangle-и-square)
- [Решение проблемы LSP](#решение-проблемы-lsp)
- [Еще один пример: Иерархия банковских счетов](#еще-один-пример-иерархия-банковских-счетов)
- [Практические примеры нарушений LSP](#практические-примеры-нарушений-lsp)
- [Практические советы по применению LSP](#практические-советы-по-применению-lsp)
- [Распространенные ошибки при применении LSP](#распространенные-ошибки-при-применении-lsp)
- [Упражнения для практики](#упражнения-для-практики)
- [Заключение по LSP](#заключение-по-lsp)

## Теоретические основы

**Принцип подстановки Лисков (LSP)** был введен Барбарой Лисков в 1987 году на конференции OOPSLA и формулируется так:

> Объекты в программе должны быть заменяемы на экземпляры их подтипов без изменения правильности выполнения программы.

Проще говоря, если у вас есть класс B, который является подклассом класса A, то вы должны иметь возможность использовать объект B вместо объекта A в любом месте программы, и программа должна продолжать работать корректно.

### Исторический контекст

Барбара Лисков представила этот принцип в своей работе "Data Abstraction and Hierarchy". Позже принцип был популяризирован Робертом Мартином как часть SOLID принципов.

### Формальное определение

Формально LSP можно определить так: "Пусть S(x) является свойством, верным для объектов x типа T. Тогда S(y) также должно быть верным для объектов y типа S, где S является подтипом T".

Это означает, что подтипы должны вести себя так, чтобы пользователь не мог отличить их от базового типа.

### Поведенческая подтипизация

LSP вводит понятие "поведенческой подтипизации", которая означает, что подтип не только должен поддерживать все операции базового типа, но и должен вести себя ожидаемо с точки зрения пользователя.

## Почему LSP важен?

### Гарантия корректности полиморфизма

- **Уверенность, что подклассы ведут себя ожидаемо**
  - Полиморфизм работает только если подклассы соответствуют контракту
  - Пользователи могут безопасно использовать подклассы через интерфейс базового класса
  - Снижается риск неожиданного поведения

- **Надежное использование наследования**
  - Наследование становится предсказуемым
  - Подклассы действительно являются "видами" базовых классов
  - Улучшается понимание иерархии классов

### Улучшение повторного использования кода

- **Можно безопасно использовать подклассы**
  - Клиентский код не нужно изменять при замене реализации
  - Компоненты становятся более универсальными
  - Уменьшается дублирование кода

- **Легко создавать библиотеки и фреймворки**
  - Пользователи могут расширять функциональность через наследование
  - Гарантируется совместимость расширений
  - Улучшается экосистема продукта

### Снижение ошибок

- **Предотвращает неожиданное поведение при замене объектов**
  - Подклассы не нарушают ожидания пользователей
  - Снижается количество багов, связанных с наследованием
  - Упрощается отладка

- **Улучшает качество кода**
  - Заставляет разработчиков тщательно проектировать иерархии
  - Предотвращает "неправильное" наследование
  - Способствует созданию более надежных систем

### Улучшение тестируемости

- **Легче тестировать иерархии классов**
  - Можно использовать одни и те же тесты для базовых классов и подклассов
  - Упрощается создание тестовых сценариев
  - Улучшается покрытие тестами

- **Подклассы проходят те же тесты, что и базовые классы**
  - Гарантируется соответствие поведению
  - Тесты становятся более надежными
  - Уменьшается количество специфичных тестов

### Повышение надежности

- **Система становится более предсказуемой**
  - Поведение подклассов ожидаемо
  - Уменьшается количество "сюрпризов" при замене компонентов
  - Улучшается доверие к системе

- **Улучшается документация и понимание**
  - Четкие контракты между классами
  - Легче понимать, как использовать подклассы
  - Улучшается коммуникация в команде

## Условия соблюдения LSP

Для соблюдения LSP подкласс должен соответствовать нескольким ключевым условиям:

### 1. Сохранение инвариантов

**Инварианты** - это условия, которые всегда должны быть истинными для объекта. Подклассы должны сохранять все инварианты базового класса.

```python
# Плохо: нарушение инвариантов
class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    @property
    def area(self):
        return self.width * self.height

class Square(Rectangle):
    def __init__(self, side):
        super().__init__(side, side)
    
    @property
    def width(self):
        return self._width
    
    @width.setter
    def width(self, value):
        self._width = value
        self._height = value  # Нарушение инварианта!
    
    @property
    def height(self):
        return self._height
    
    @height.setter
    def height(self, value):
        self._height = value
        self._width = value  # Нарушение инварианта!
```
В этом примере Square нарушает инвариант Rectangle, где ширина и высота независимы.

### 2. Не усиление предусловий

**Предусловия** - это условия, которые должны быть истинными перед вызовом метода. Подклассы не должны делать предусловия строже, чем в базовом классе.
```python
# Плохо: усиление предусловий
class BaseProcessor:
    def process(self, data):
        # Принимает любые данные
        return data.upper()

class StrictProcessor(BaseProcessor):
    def process(self, data):
        # Усиливает предусловие - теперь требует строку
        if not isinstance(data, str):
            raise TypeError("Data must be string")
        return data.upper()
```
StrictProcessor нарушает LSP, так как он не может обработать данные, которые мог бы обработать BaseProcessor.

### 3. Не ослабление постусловий

**Постусловия** - это условия, которые гарантируются после выполнения метода. Подклассы не должны делать постусловия слабее, чем в базовом классе.
```python
# Плохо: ослабление постусловий
class DataValidator:
    def validate(self, data):
        # Гарантирует, что возвращает bool
        return isinstance(data, str)

class LazyValidator(DataValidator):
    def validate(self, data):
        # Ослабляет постусловие - может вернуть None
        if data is None:
            return None
        return isinstance(data, str)
```
LazyValidator нарушает LSP, так как он не гарантирует тот же результат, что и DataValidator.

### 4. Сохранение истории

**История** - это свойства объекта, которые не должны меняться. Подклассы не должны изменять свойства, которые базовый класс не изменяет.
```python
# Плохо: изменение истории
class ImmutablePoint:
    def __init__(self, x, y):
        self._x = x
        self._y = y
    
    @property
    def x(self):
        return self._x
    
    @property
    def y(self):
        return self._y

class MutablePoint(ImmutablePoint):
    def __init__(self, x, y):
        super().__init__(x, y)
    
    @property
    def x(self):
        return self._x
    
    @x.setter
    def x(self, value):
        self._x = value  # Изменяет неизменяемое свойство!
    
    @property
    def y(self):
        return self._y
    
    @y.setter
    def y(self, value):
        self._y = value  # Изменяет неизменяемое свойство!
```
MutablePoint нарушает LSP, так как он изменяет свойства, которые ImmutablePoint обещал не изменять.

## Распознавание нарушений LSP

### Признаки нарушения LSP

1. **Проверка типа объекта (isinstance) перед использованием**
	```python
	def process_shape(shape):
		if isinstance(shape, Circle):
			shape.draw_circle()
		elif isinstance(shape, Rectangle):
			shape.draw_rectangle()
	```
	 Это указывает на то, что подклассы ведут себя по-разному.

2. **Подкласс выбрасывает исключения, которые не выбрасывает базовый класс**
	```python
	class Bird:
		def fly(self):
			print("Flying")

	class Penguin(Bird):
		def fly(self):
		    raise NotImplementedError("Penguins can't fly")
	```
3. **Подкласс возвращает значения другого типа, чем базовый класс**
	```python
	class DataProcessor:
	    def process(self, data):
	        return str(data)

	class NumberProcessor(DataProcessor):
	    def process(self, data):
	        return int(data)  # Другой тип!
	```