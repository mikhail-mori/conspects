## Глава 1: Single Responsibility Principle (SRP) - Принцип единственной ответственности

### Теоретические основы

**Принцип единственной ответственности (SRP)** гласит:

> Класс должен иметь только одну причину для изменения.

Это означает, что каждый класс должен решать только одну задачу и нести ответственность только за один аспект функциональности системы. Если у класса есть более одной ответственности, он становится слишком сложным, его трудно поддерживать и изменять.

SRP тесно связан с концепцией **разделения ответственности (separation of concerns)**, которая предлагает разделять программу на отдельные секции, каждая из которых адресует отдельную задачу.

### Почему SRP важен?

1. **Упрощение понимания кода** - класс с одной ответственностью легче понять
2. **Улучшение тестируемости** - легче писать тесты для класса с одной функцией
3. **Снижение риска при изменениях** - изменение одной ответственности не влияет на другие
4. **Улучшение переиспользования** - классы с одной ответственностью легче переиспользовать
5. **Уменьшение связанности** - классы становятся менее зависимыми друг от друга

### Распознавание нарушений SRP

Признаки нарушения SRP:

- Класс имеет слишком много методов
- Методы класса решают разные задачи
- Класс работает с разными уровнями абстракции
- При изменении одного требования приходится изменять несколько методов класса
- Класс имеет несколько причин для изменения

### Пример нарушения SRP

Рассмотрим класс `FileManager`, который нарушает SRP:

```python
class FileManager:
    def __init__(self, filename):
        self.filename = filename
    
    def read(self):
        """Читает содержимое файла"""
        with open(self.filename, 'r') as file:
            return file.read()
    
    def write(self, content):
        """Записывает содержимое в файл"""
        with open(self.filename, 'w') as file:
            file.write(content)
    
    def compress(self):
        """Сжимает файл в ZIP архив"""
        import zipfile
        with zipfile.ZipFile(f"{self.filename}.zip", 'w') as zipf:
            zipf.write(self.filename)
    
    def decompress(self):
        """Распаковывает ZIP архив"""
        import zipfile
        with zipfile.ZipFile(f"{self.filename}.zip", 'r') as zipf:
            zipf.extractall()
```

**Проблема:** Класс `FileManager` имеет две ответственности:

1. Управление файлами (чтение и запись)
2. Работа с архивами (сжатие и распаковка)

Это нарушение SRP, потому что:

- Если изменится логика работы с файлами, придется менять класс
- Если изменится логика сжатия, тоже придется менять класс
- Класс становится слишком сложным и трудно тестируемым